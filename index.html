<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è‹±æ–‡å–®å­—å°å­¸å ‚</title>
  
  <!-- 1. å¼•å…¥ Tailwind CSS (æ¨£å¼åº«) -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- 2. å¼•å…¥ React å’Œ ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  
  <!-- 3. å¼•å…¥ Babel (è®“ç€è¦½å™¨çœ‹å¾—æ‡‚ JSX) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- 4. å¼•å…¥ Tesseract.js (OCR æ–‡å­—è¾¨è­˜) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    body { font-family: system-ui, -apple-system, sans-serif; }
    /* éš±è—æ²è»¸ä½†ä¿ç•™åŠŸèƒ½ */
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
  </style>
</head>
<body class="bg-sky-100 min-h-screen">
  
  <div id="root"></div>

  <!-- é€™è£¡é–‹å§‹å¯« React ç¨‹å¼ç¢¼ï¼Œæ³¨æ„ type="text/babel" -->
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- åœ–ç¤ºçµ„ä»¶ (ç›´æ¥å…§å»ºï¼Œè§£æ±º import éŒ¯èª¤) ---
    const IconBase = ({ children, size = 24, className = "" }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        {children}
      </svg>
    );

    const Camera = (props) => <IconBase {...props}><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></IconBase>;
    const Volume2 = (props) => <IconBase {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></IconBase>;
    const BookOpen = (props) => <IconBase {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconBase>;
    const Brain = (props) => <IconBase {...props}><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 1.98-3A2.5 2.5 0 0 1 9.5 2Z"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-1.98-3A2.5 2.5 0 0 0 14.5 2Z"/></IconBase>;
    const Settings = (props) => <IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>;
    const Trash2 = (props) => <IconBase {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></IconBase>;
    const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>;
    const Plus = (props) => <IconBase {...props}><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></IconBase>;
    const ChevronDown = (props) => <IconBase {...props}><polyline points="6 9 12 15 18 9"/></IconBase>;
    const AlertCircle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></IconBase>;
    const CheckCircle = (props) => <IconBase {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></IconBase>;

    // -----------------------------------------------------------------------------
    // æ¨¡æ“¬å­—å…¸è³‡æ–™
    // -----------------------------------------------------------------------------
    const MOCK_DICTIONARY = {
      apple: { syllable: 'ap-ple', kk: '[ËˆÃ¦pÉ™l]', translation: 'è˜‹æœ', sentence: 'I eat an apple every day.' },
      banana: { syllable: 'ba-na-na', kk: '[bÉ™ËˆnÃ¦nÉ™]', translation: 'é¦™è•‰', sentence: 'Monkeys love bananas.' },
      cat: { syllable: 'cat', kk: '[kÃ¦t]', translation: 'è²“', sentence: 'The cat is sleeping on the sofa.' },
      dog: { syllable: 'dog', kk: '[dÉ”g]', translation: 'ç‹—', sentence: 'My dog likes to run in the park.' },
      elephant: { syllable: 'el-e-phant', kk: '[ËˆÉ›lÉ™fÉ™nt]', translation: 'å¤§è±¡', sentence: 'The elephant has a long nose.' },
      book: { syllable: 'book', kk: '[bÊŠk]', translation: 'æ›¸', sentence: 'She is reading a book.' },
      school: { syllable: 'school', kk: '[skul]', translation: 'å­¸æ ¡', sentence: 'I go to school by bus.' },
      teacher: { syllable: 'teach-er', kk: '[ËˆtitÊƒÉ™r]', translation: 'è€å¸«', sentence: 'The teacher writes on the board.' },
      student: { syllable: 'stu-dent', kk: '[ËˆstudÉ™nt]', translation: 'å­¸ç”Ÿ', sentence: 'The student is doing homework.' },
      happy: { syllable: 'hap-py', kk: '[ËˆhÃ¦pi]', translation: 'å¿«æ¨‚çš„', sentence: 'I am very happy today.' },
      red: { syllable: 'red', kk: '[rÉ›d]', translation: 'ç´…è‰²', sentence: 'Her dress is red.' },
      blue: { syllable: 'blue', kk: '[blu]', translation: 'è—è‰²', sentence: 'The sky is blue.' },
    };

    const DEFAULT_LEVELS = ['Level 1', 'Level 2', 'Level 3', 'Level 4', 'Level 5', 'Hard'];

    const guessSyllables = (word) => {
      const clean = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '').replace(/^y/, '');
      const matches = clean.match(/[aeiouy]{1,2}/g);
      return matches ? matches.join('-') : word;
    };

    // -----------------------------------------------------------------------------
    // App Component
    // -----------------------------------------------------------------------------
    function App() {
      const [view, setView] = useState('home');
      const [words, setWords] = useState([]);
      const [loading, setLoading] = useState(false);
      const [levels, setLevels] = useState(DEFAULT_LEVELS);
      const [filterLevel, setFilterLevel] = useState('All');
      const [quizConfig, setQuizConfig] = useState({ level: 'All', count: 10, source: 'all' });
      const [currentQuiz, setCurrentQuiz] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [userAnswer, setUserAnswer] = useState('');
      const [quizResults, setQuizResults] = useState(null);
      const [modal, setModal] = useState({ show: false, type: 'info', title: '', message: '', onConfirm: null });

      const workerRef = useRef(null);

      useEffect(() => {
        const savedWords = localStorage.getItem('english_kids_words');
        if (savedWords) {
          setWords(JSON.parse(savedWords));
        } else {
          const initialWords = [
            { id: 1, text: 'apple', level: 'Level 1', ...MOCK_DICTIONARY.apple },
            { id: 2, text: 'cat', level: 'Level 1', ...MOCK_DICTIONARY.cat },
            { id: 3, text: 'banana', level: 'Level 2', ...MOCK_DICTIONARY.banana },
          ];
          setWords(initialWords);
          localStorage.setItem('english_kids_words', JSON.stringify(initialWords));
        }

        const savedLevels = localStorage.getItem('english_kids_levels');
        if (savedLevels) {
          setLevels(JSON.parse(savedLevels));
        }
      }, []);

      useEffect(() => {
        localStorage.setItem('english_kids_words', JSON.stringify(words));
      }, [words]);

      useEffect(() => {
        localStorage.setItem('english_kids_levels', JSON.stringify(levels));
      }, [levels]);

      const showAlert = (title, message) => {
        setModal({ show: true, type: 'info', title, message, onConfirm: null });
      };

      const showConfirm = (title, message, onConfirmAction) => {
        setModal({ show: true, type: 'confirm', title, message, onConfirm: onConfirmAction });
      };

      const closeModal = () => {
        setModal(prev => ({ ...prev, show: false }));
      };

      const handleModalConfirm = () => {
        if (modal.onConfirm) modal.onConfirm();
        closeModal();
      };

      const speak = (text) => {
        if (!text) return;
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';
        utterance.rate = 0.8;
        window.speechSynthesis.speak(utterance);
      };

      const handleAddLevel = () => {
        const newName = `New Level ${levels.length + 1}`;
        setLevels([...levels, newName]);
      };

      const handleRenameLevel = (index, newName) => {
        const oldName = levels[index];
        if (oldName === newName) return;
        const newLevels = [...levels];
        newLevels[index] = newName;
        setLevels(newLevels);
        const updatedWords = words.map(w => w.level === oldName ? { ...w, level: newName } : w);
        setWords(updatedWords);
        if (filterLevel === oldName) setFilterLevel(newName);
        if (quizConfig.level === oldName) setQuizConfig(prev => ({ ...prev, level: newName }));
      };

      const handleDeleteLevel = (index) => {
        const levelName = levels[index];
        const wordsInLevel = words.filter(w => w.level === levelName);
        if (wordsInLevel.length > 0) {
          showConfirm("åˆªé™¤ç­‰ç´šç¢ºèª", `ã€Œ${levelName || 'æœªå‘½å'}ã€è£¡é¢é‚„æœ‰ ${wordsInLevel.length} å€‹å–®å­—ã€‚\nç¢ºå®šè¦åˆªé™¤å—ï¼Ÿ\nå–®å­—å°‡è®Šæ›´ç‚ºã€ŒUncategorizedã€ã€‚`, () => {
             const updatedWords = words.map(w => w.level === levelName ? { ...w, level: 'Uncategorized' } : w);
             setWords(updatedWords);
             const newLevels = levels.filter((_, i) => i !== index);
             setLevels(newLevels);
             if (filterLevel === levelName) setFilterLevel('All');
          });
        } else {
          const newLevels = levels.filter((_, i) => i !== index);
          setLevels(newLevels);
          if (filterLevel === levelName) setFilterLevel('All');
        }
      };

      const handleImageScan = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        if (!window.Tesseract) {
          showAlert("ç³»çµ±æç¤º", "OCR å¼•æ“è¼‰å…¥ä¸­ï¼Œè«‹ç¨å¾Œå†è©¦...");
          return;
        }
        setLoading(true);
        try {
          const { data: { text } } = await window.Tesseract.recognize(file, 'eng');
          const rawWords = text.match(/\b[a-zA-Z]{3,}\b/g) || [];
          const uniqueWords = [...new Set(rawWords.map(w => w.toLowerCase()))];
          const newWords = uniqueWords.map(w => {
            const dictEntry = MOCK_DICTIONARY[w] || {};
            return {
              id: Date.now() + Math.random(),
              text: w,
              level: levels[0] || 'Uncategorized',
              syllable: dictEntry.syllable || guessSyllables(w),
              kk: dictEntry.kk || '[?]',
              translation: dictEntry.translation || 'è‡ªè¨‚',
              sentence: dictEntry.sentence || `This is a ${w}.`,
            };
          });
          const currentWordsText = words.map(w => w.text);
          const filteredNewWords = newWords.filter(w => !currentWordsText.includes(w.text));
          if (filteredNewWords.length === 0) {
            showAlert("æƒæçµæœ", "æ²’æœ‰åµæ¸¬åˆ°æ–°å–®å­—ï¼Œæˆ–å–®å­—å·²å­˜åœ¨åº«ä¸­ã€‚");
          } else {
            setWords(prev => [...prev, ...filteredNewWords]);
            showAlert("æƒææˆåŠŸ", `æˆåŠŸæ–°å¢ ${filteredNewWords.length} å€‹å–®å­—ï¼`);
            setView('wordbank');
          }
        } catch (err) {
          console.error(err);
          showAlert("éŒ¯èª¤", "è¾¨è­˜å¤±æ•—ï¼Œè«‹é‡è©¦");
        } finally {
          setLoading(false);
        }
      };

      const deleteWord = (id) => {
        showConfirm("åˆªé™¤å–®å­—", "ç¢ºå®šè¦åˆªé™¤é€™å€‹å–®å­—å—ï¼Ÿ", () => {
          setWords(prev => prev.filter(w => w.id !== id));
        });
      };

      const updateWord = (id, field, value) => {
        setWords(prev => prev.map(w => w.id === id ? { ...w, [field]: value } : w));
      };

      const startPractice = (mistakesToRetry = null) => {
        let pool = [];
        if (mistakesToRetry) {
          pool = mistakesToRetry;
        } else {
          pool = quizConfig.level === 'All' ? [...words] : words.filter(w => w.level === quizConfig.level);
          pool.sort(() => Math.random() - 0.5);
          const count = parseInt(quizConfig.count);
          if (!isNaN(count) && count > 0) pool = pool.slice(0, count);
        }

        if (pool.length === 0) {
          showAlert("æç¤º", "è©²ç­‰ç´šæ²’æœ‰å–®å­—å¯ä¾›ç·´ç¿’ï¼");
          return;
        }
        setCurrentQuiz(pool);
        setCurrentIndex(0);
        setUserAnswer('');
        setQuizResults(null);
        setView('practice');
        setTimeout(() => speak(pool[0].text), 500);
      };

      const submitAnswer = () => {
        const currentWord = currentQuiz[currentIndex];
        const isCorrect = userAnswer.trim().toLowerCase() === currentWord.text.toLowerCase();
        const resultEntry = { ...currentWord, userAnswer, isCorrect };
        const newResults = quizResults ? { ...quizResults } : { score: 0, mistakes: [], history: [] };
        if (!newResults.history) newResults.history = [];
        newResults.history.push(resultEntry);
        
        if (isCorrect) newResults.score = (newResults.score || 0) + 1;
        else newResults.mistakes = [...(newResults.mistakes || []), resultEntry];

        setQuizResults(newResults);
        if (currentIndex < currentQuiz.length - 1) {
          setCurrentIndex(prev => prev + 1);
          setUserAnswer('');
          setTimeout(() => speak(currentQuiz[currentIndex + 1].text), 300);
        } else {
          setView('results');
        }
      };

      // Views
      const renderHome = () => (
        <div className="flex flex-col items-center justify-center min-h-[60vh] space-y-6 relative">
          <h1 className="text-4xl font-bold text-blue-600 mb-4 text-center">ğŸ¦ è‹±æ–‡å–®å­—å°å­¸å ‚</h1>
          <button onClick={() => setView('settings')} className="absolute top-0 right-4 p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-full transition">
            <Settings size={28} />
          </button>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-md p-4">
            <button onClick={() => setView('scan')} className="p-6 bg-yellow-400 rounded-2xl shadow-lg hover:bg-yellow-300 transition flex flex-col items-center">
              <Camera size={48} className="text-white mb-2" />
              <span className="text-xl font-bold text-white">æ‹ç…§åŠ å–®å­—</span>
            </button>
            <button onClick={() => setView('wordbank')} className="p-6 bg-green-500 rounded-2xl shadow-lg hover:bg-green-400 transition flex flex-col items-center">
              <BookOpen size={48} className="text-white mb-2" />
              <span className="text-xl font-bold text-white">å–®å­—åº«</span>
            </button>
            <button onClick={() => setView('setup')} className="p-6 bg-blue-500 rounded-2xl shadow-lg hover:bg-blue-400 transition flex flex-col items-center col-span-1 md:col-span-2">
              <Brain size={48} className="text-white mb-2" />
              <span className="text-xl font-bold text-white">è½å¯«ç·´ç¿’</span>
            </button>
          </div>
        </div>
      );

      const renderSettings = () => (
        <div className="p-4 max-w-md mx-auto min-h-screen">
          <div className="flex items-center mb-6">
            <h2 className="text-2xl font-bold text-gray-800 flex-1">âš™ï¸ ç­‰ç´šè¨­å®š</h2>
          </div>
          <div className="bg-white rounded-xl shadow-lg p-4 space-y-4">
            <p className="text-sm text-gray-500 bg-blue-50 p-3 rounded-lg mb-4">æç¤ºï¼šä¿®æ”¹åç¨±å¾Œï¼Œå–®å­—åº«ä¸­çš„å–®å­—æœƒè‡ªå‹•æ›´æ–°ã€‚</p>
            {levels.map((level, index) => (
              <div key={index} className="flex items-center gap-2">
                <input 
                  className="flex-1 p-3 bg-gray-50 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  value={level}
                  onChange={(e) => handleRenameLevel(index, e.target.value)}
                  placeholder="è¼¸å…¥ç­‰ç´šåç¨±"
                />
                <button onClick={() => handleDeleteLevel(index)} className="p-3 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-lg transition">
                  <Trash2 size={20} />
                </button>
              </div>
            ))}
            <button onClick={handleAddLevel} className="w-full py-3 mt-4 border-2 border-dashed border-gray-300 text-gray-500 rounded-lg hover:border-blue-400 hover:text-blue-500 hover:bg-blue-50 transition flex items-center justify-center gap-2 font-bold">
              <Plus size={20} /> æ–°å¢ç­‰ç´š
            </button>
          </div>
          <button onClick={() => setView('home')} className="mt-8 w-full py-3 bg-gray-200 text-gray-700 rounded-xl font-bold">è¿”å›é¦–é </button>
        </div>
      );

      const renderScan = () => (
        <div className="flex flex-col items-center p-4">
          <h2 className="text-2xl font-bold text-gray-800 mb-6">ğŸ“¸ æ‹èª²æœ¬åŠ å–®å­—</h2>
          {loading ? (
            <div className="flex flex-col items-center space-y-4 py-10">
              <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-blue-500"></div>
              <p className="text-lg text-gray-600">è¾¨è­˜ä¸­...</p>
            </div>
          ) : (
            <div className="w-full max-w-md bg-white p-6 rounded-xl shadow-md space-y-4">
              <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center bg-gray-50 hover:bg-gray-100 transition relative">
                <input type="file" accept="image/*" onChange={handleImageScan} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" />
                <Camera className="mx-auto text-gray-400 mb-2" size={32} />
                <p className="text-gray-500 font-medium">é»æ“Šé–‹å•Ÿç›¸æ©Ÿæˆ–ä¸Šå‚³åœ–ç‰‡</p>
              </div>
              <p className="text-sm text-blue-700 bg-blue-50 p-4 rounded-lg">è«‹ç¢ºä¿å…‰ç·šå……è¶³ï¼Œæ–‡å­—æ¸…æ™°ã€‚</p>
            </div>
          )}
          <button onClick={() => setView('home')} className="mt-6 text-gray-500 underline">è¿”å›é¦–é </button>
        </div>
      );

      const renderWordBank = () => {
        const uniqueWordLevels = new Set(words.map(w => w.level));
        const extraLevels = [...uniqueWordLevels].filter(l => !levels.includes(l) && l !== 'All');
        const allLevels = ['All', ...levels, ...extraLevels];
        const filteredWords = filterLevel === 'All' ? words : words.filter(w => w.level === filterLevel);

        return (
          <div className="p-4 max-w-4xl mx-auto pb-20">
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-2xl font-bold text-gray-800">ğŸ“š å–®å­—åº« ({words.length})</h2>
              <button onClick={() => setView('scan')} className="bg-blue-500 text-white p-2 rounded-full shadow hover:bg-blue-600">
                <Plus size={24} />
              </button>
            </div>
            <div className="flex space-x-2 overflow-x-auto pb-4 mb-2 no-scrollbar">
              {allLevels.map(lvl => (
                <button key={lvl} onClick={() => setFilterLevel(lvl)} className={`px-4 py-2 rounded-full whitespace-nowrap text-sm font-medium transition ${filterLevel === lvl ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`}>
                  {lvl}
                </button>
              ))}
            </div>
            <div className="space-y-4">
              {filteredWords.length === 0 ? <div className="text-center py-10 text-gray-500">æ²’æœ‰å–®å­—</div> : filteredWords.map(word => (
                <div key={word.id} className="bg-white p-4 rounded-xl shadow border-l-4 border-blue-400 flex flex-col md:flex-row gap-4">
                  <div className="flex-1">
                    <div className="flex items-baseline space-x-2 mb-1">
                      <h3 className="text-2xl font-bold text-gray-800">{word.text}</h3>
                      <span className="text-sm text-gray-500 font-mono bg-gray-100 px-2 rounded">{word.kk}</span>
                      <span className="text-xs text-blue-500 border border-blue-200 px-1 rounded">{word.syllable}</span>
                    </div>
                    <div className="flex items-center space-x-2 mb-2 bg-gray-50 p-2 rounded-lg">
                      <div className="flex items-center space-x-1 border-r border-gray-300 pr-2 relative">
                        <span className="text-xs font-bold text-gray-500">Lv:</span>
                        <select className="appearance-none text-sm font-semibold bg-white border border-gray-200 text-blue-600 pl-2 pr-6 py-1 rounded focus:outline-none" value={word.level} onChange={(e) => updateWord(word.id, 'level', e.target.value)}>
                          {allLevels.filter(l => l !== 'All').map(l => <option key={l} value={l}>{l}</option>)}
                        </select>
                        <ChevronDown size={14} className="absolute right-1 top-1/2 -translate-y-1/2 text-gray-400 pointer-events-none"/>
                      </div>
                      <input className="flex-1 text-sm bg-transparent border-b border-dashed border-gray-300 focus:outline-none px-1" placeholder="è¼¸å…¥ä¸­æ–‡ç¿»è­¯..." value={word.translation} onChange={(e) => updateWord(word.id, 'translation', e.target.value)} />
                    </div>
                    <p className="text-gray-600 italic text-sm bg-gray-50 p-2 rounded flex items-center justify-between">
                       <span>Ex: {word.sentence}</span>
                       <button onClick={() => speak(word.sentence)} className="ml-2 text-blue-400 hover:text-blue-600"><Volume2 size={16}/></button>
                    </p>
                  </div>
                  <div className="flex md:flex-col justify-between items-end gap-2 pl-2">
                    <button onClick={() => speak(word.text)} className="p-3 bg-yellow-100 text-yellow-600 rounded-full hover:bg-yellow-200"><Volume2 size={24}/></button>
                    <button onClick={() => deleteWord(word.id)} className="p-2 text-red-400 bg-red-50 rounded-full hover:bg-red-500 hover:text-white"><Trash2 size={20}/></button>
                  </div>
                </div>
              ))}
            </div>
            <div className="h-16"></div>
          </div>
        );
      };

      const renderSetup = () => {
        const uniqueWordLevels = new Set(words.map(w => w.level));
        const extraLevels = [...uniqueWordLevels].filter(l => !levels.includes(l));
        const availableLevels = ['All', ...levels, ...extraLevels];
        return (
          <div className="p-6 max-w-md mx-auto flex flex-col h-[80vh] justify-center">
            <h2 className="text-3xl font-bold text-center text-blue-600 mb-8">ğŸ§ è½å¯«æŒ‘æˆ°è¨­å®š</h2>
            <div className="space-y-6 bg-white p-6 rounded-2xl shadow-lg">
              <div>
                <label className="block text-gray-700 font-bold mb-2">é¸æ“‡ç­‰ç´š</label>
                <select className="w-full p-3 bg-gray-50 rounded-lg border border-gray-200" value={quizConfig.level} onChange={(e) => setQuizConfig({...quizConfig, level: e.target.value})}>
                  {availableLevels.map(l => <option key={l} value={l}>{l}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-gray-700 font-bold mb-2">é¡Œç›®æ•¸é‡</label>
                <div className="flex items-center space-x-4">
                  <input 
                    type="text" 
                    inputMode="numeric" 
                    pattern="[0-9]*" 
                    className="w-full p-3 bg-gray-50 rounded-lg border border-gray-200 text-center text-lg font-bold"
                    value={quizConfig.count} 
                    onChange={(e) => setQuizConfig({...quizConfig, count: e.target.value.replace(/[^0-9]/g, '')})}
                    onBlur={(e) => {
                      let val = parseInt(e.target.value);
                      if (isNaN(val) || val < 1) val = 1;
                      if (val > 50) val = 50;
                      setQuizConfig({...quizConfig, count: val});
                    }}
                  />
                  <span className="text-gray-500">é¡Œ</span>
                </div>
              </div>
              <button onClick={() => startPractice()} className="w-full py-4 bg-blue-600 text-white rounded-xl text-xl font-bold shadow-lg hover:bg-blue-700 mt-4">é–‹å§‹æŒ‘æˆ°ï¼ğŸš€</button>
            </div>
            <button onClick={() => setView('home')} className="mt-8 text-center text-gray-500">æ”¾æ£„ä¸¦è¿”å›</button>
          </div>
        );
      };

      const renderPractice = () => {
        const progress = ((currentIndex + 1) / currentQuiz.length) * 100;
        return (
          <div className="flex flex-col h-screen max-w-md mx-auto bg-gray-50">
            <div className="w-full h-2 bg-gray-200"><div className="h-full bg-blue-500 transition-all duration-300" style={{width: `${progress}%`}}></div></div>
            <div className="flex-1 flex flex-col items-center justify-center p-6 space-y-8">
              <div className="text-gray-500 font-bold">Q {currentIndex + 1} / {currentQuiz.length}</div>
              <button onClick={() => speak(currentQuiz[currentIndex].text)} className="w-32 h-32 bg-yellow-400 rounded-full shadow-xl flex items-center justify-center hover:bg-yellow-300">
                <Volume2 size={64} className="text-white" />
              </button>
              <div className="w-full space-y-2">
                <input type="text" autoFocus placeholder="è¼¸å…¥å–®å­—..." className="w-full p-4 text-center text-2xl font-bold rounded-xl border-2 border-blue-200 focus:outline-none bg-white shadow-inner lowercase" value={userAnswer} onChange={(e) => setUserAnswer(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && submitAnswer()} />
              </div>
            </div>
            <div className="p-6 bg-white shadow-inner-top">
              <button onClick={submitAnswer} disabled={!userAnswer} className={`w-full py-4 rounded-xl text-xl font-bold shadow-lg transition ${userAnswer ? 'bg-green-500 text-white' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`}>
                {currentIndex === currentQuiz.length - 1 ? 'äº¤å· ğŸ' : 'ä¸‹ä¸€é¡Œ â”'}
              </button>
            </div>
          </div>
        );
      };

      const renderResults = () => {
        const score = quizResults?.score || 0;
        const total = currentQuiz.length;
        const mistakes = quizResults?.mistakes || [];
        const percentage = Math.round((score / total) * 100);
        return (
          <div className="p-4 max-w-md mx-auto min-h-screen pb-20">
            <div className="bg-white rounded-2xl shadow-lg p-6 mb-6 text-center">
              <h2 className="text-2xl font-bold text-gray-800 mb-2">æ¸¬é©—çµæœ</h2>
              <div className={`text-6xl font-black mb-2 ${percentage === 100 ? 'text-green-500' : percentage >= 60 ? 'text-blue-500' : 'text-red-500'}`}>
                {score} <span className="text-2xl text-gray-400">/ {total}</span>
              </div>
              <div className="flex gap-2 justify-center mt-4">
                <button onClick={() => setView('home')} className="px-4 py-2 bg-gray-100 rounded-lg text-gray-600 font-bold">å›é¦–é </button>
                {mistakes.length > 0 && <button onClick={() => startPractice(mistakes)} className="px-4 py-2 bg-red-100 text-red-600 rounded-lg font-bold flex items-center gap-1"><RotateCcw size={16}/> é‡ç·´éŒ¯é¡Œ</button>}
              </div>
            </div>
            {mistakes.length > 0 ? (
              <div className="space-y-4">
                <h3 className="font-bold text-gray-700 pl-2">éŒ¯é¡Œæª¢è¨ ({mistakes.length})</h3>
                {mistakes.map((m, idx) => (
                  <div key={idx} className="bg-white p-4 rounded-xl shadow border-l-4 border-red-400">
                    <div className="flex justify-between items-start mb-2">
                      <h4 className="text-xl font-bold text-gray-800">{m.text}</h4>
                      <button onClick={() => speak(m.text)} className="text-blue-500"><Volume2 size={20}/></button>
                    </div>
                    <div className="grid grid-cols-2 gap-2 text-sm">
                      <div className="bg-red-50 p-2 rounded"><span className="block text-xs text-red-400">ä½ çš„ç­”æ¡ˆ</span><span className="font-mono text-red-700 font-bold line-through">{m.userAnswer || '(æœªä½œç­”)'}</span></div>
                      <div className="bg-green-50 p-2 rounded"><span className="block text-xs text-green-400">æ­£ç¢ºç­”æ¡ˆ</span><span className="font-mono text-green-700 font-bold">{m.text}</span></div>
                    </div>
                  </div>
                ))}
              </div>
            ) : <div className="text-center p-10 bg-green-50 rounded-xl border border-green-200 text-green-700 font-bold">å®Œç¾ï¼æ²’æœ‰ä»»ä½•éŒ¯é¡Œï¼âœ¨</div>}
          </div>
        );
      };

      return (
        <div>
          {view === 'home' && renderHome()}
          {view === 'settings' && renderSettings()}
          {view === 'scan' && renderScan()}
          {view === 'wordbank' && renderWordBank()}
          {view === 'setup' && renderSetup()}
          {view === 'practice' && renderPractice()}
          {view === 'results' && renderResults()}
          
          {modal.show && (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4 animate-in fade-in duration-200">
              <div className="bg-white rounded-2xl shadow-2xl max-w-sm w-full overflow-hidden">
                <div className={`p-4 flex items-center gap-3 ${modal.type === 'confirm' ? 'bg-red-50' : 'bg-blue-50'}`}>
                  {modal.type === 'confirm' ? <AlertCircle className="text-red-500" size={24} /> : <CheckCircle className="text-blue-500" size={24} />}
                  <h3 className={`font-bold text-lg ${modal.type === 'confirm' ? 'text-red-700' : 'text-blue-700'}`}>{modal.title}</h3>
                </div>
                <div className="p-6"><p className="text-gray-600 whitespace-pre-wrap leading-relaxed">{modal.message}</p></div>
                <div className="p-4 bg-gray-50 flex justify-end gap-3">
                  {modal.type === 'confirm' && <button onClick={closeModal} className="px-4 py-2 rounded-lg text-gray-600 font-bold hover:bg-gray-200 transition">å–æ¶ˆ</button>}
                  <button onClick={handleModalConfirm} className={`px-6 py-2 rounded-lg text-white font-bold shadow-md transition ${modal.type === 'confirm' ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'}`}>{modal.type === 'confirm' ? 'ç¢ºå®šåˆªé™¤' : 'æˆ‘çŸ¥é“äº†'}</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
